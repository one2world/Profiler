# Unity Memory Profiler WPF å¤åˆ»é¡¹ç›® - è¯¦ç»†å¼€å‘è®¡åˆ’

## ğŸ¯ é¡¹ç›®ç›®æ ‡

å®Œå…¨å¤åˆ» Unity Memory Profiler Package (com.unity.memoryprofiler@1.1.6) çš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ï¼Œæä¾›ç‹¬ç«‹çš„ WPF æ¡Œé¢å·¥å…·ç”¨äºåˆ†æ Unity å†…å­˜å¿«ç…§ã€‚

**å½“å‰å®Œæˆåº¦**: 80%  
**é¢„è®¡å‰©ä½™å·¥ä½œé‡**: 3-4 å‘¨  
**å›¢é˜Ÿè§„æ¨¡å»ºè®®**: 1-2 åå¼€å‘è€…

---

## ğŸ“… å¼€å‘è·¯çº¿å›¾

```
ç¬¬1å‘¨: ä¿®å¤ä¸¥é‡é”™è¯¯ + PathsToRoot æ·±åº¦å®ç°
ç¬¬2å‘¨: å®Œå–„è¿‡æ»¤/æœç´¢ + Unity Objects è¡¥å…¨
ç¬¬3å‘¨: Memory Map è§†å›¾ + UI/UX ä¼˜åŒ–
ç¬¬4å‘¨: æµ‹è¯• + æ–‡æ¡£ + æ‰“ç£¨ç»†èŠ‚
```

---

## âœ… é˜¶æ®µ 0: çŠ¶æ€ç¡®è®¤ (å·²å®Œæˆ)

### ä»»åŠ¡ 0.1: TreeListView è¿ç§»çŠ¶æ€ âœ… å·²å®Œæˆ

**çŠ¶æ€**: âœ… **å·²å®Œæˆ**
- è‡ªå®šä¹‰ TreeListView å·²è¢«é—å¼ƒå¹¶åˆ é™¤
- é¡¹ç›®å·²æˆåŠŸè¿ç§»åˆ° **DevExpress TreeListControl**
- `AllTrackedMemoryView.xaml` å’Œ `UnityObjectsView.xaml` éƒ½åœ¨ä½¿ç”¨ `dxg:TreeListControl`

**éªŒè¯**: 
```xml
<!-- AllTrackedMemoryView.xaml å·²ä½¿ç”¨ DevExpress -->
xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
<dxg:TreeListControl ItemsSource="{Binding FilteredRootNodes}" ...>
```

---

## ğŸš¨ é˜¶æ®µ 1: éªŒè¯å’Œä¿®å¤ (1 å¤©)

### ä»»åŠ¡ 1.1: éªŒè¯é¡¹ç›®ç¼–è¯‘çŠ¶æ€ âš ï¸ HIGH

**ç›®æ ‡**: ç¡®ä¿é¡¹ç›®å¯ä»¥æ­£å¸¸ç¼–è¯‘å’Œè¿è¡Œ

**æ­¥éª¤**:

```bash
# æ¸…ç†å¹¶é‡æ–°æ„å»º
cd E:\1_code_new\Profiler
dotnet clean
dotnet restore
dotnet build UnityMemoryProfilerWPF.sln -c Debug
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] é¡¹ç›®æˆåŠŸç¼–è¯‘ (0 errors)
- [ ] æ‰€æœ‰è§†å›¾æ­£å¸¸æ˜¾ç¤º
- [ ] DevExpress TreeListControl åŠŸèƒ½æ­£å¸¸
  - [ ] æ ‘å½¢å±•å¼€/æŠ˜å 
  - [ ] æ’åº
  - [ ] é€‰æ‹©èŠ‚ç‚¹è§¦å‘ SelectionDetails æ›´æ–°

**é¢„è®¡æ—¶é—´**: 30 åˆ†é’Ÿ - 1 å°æ—¶

---

### ä»»åŠ¡ 1.2: å¤„ç†æœªæäº¤ä¿®æ”¹ âš ï¸ MEDIUM

**ç›®æ ‡**: æ•´ç†æœªæäº¤çš„ä¿®æ”¹ï¼Œç¡®ä¿ä»£ç åº“å¹²å‡€

#### æ­¥éª¤ 1.2.1: å®¡æŸ¥ä¿®æ”¹å†…å®¹
```bash
git status
git diff --stat
```

**æœªæäº¤æ–‡ä»¶åˆ—è¡¨**:
- `ManagedObjectInspector.xaml.cs` - å¢å¼ºåŠŸèƒ½
- `SelectionDetailsPanel.xaml.cs` - ä¼˜åŒ–
- `MainWindow.xaml.cs` - æ³¨é‡Šæ›´æ–°
- `SnapshotIssuesModelBuilder.cs` - ä¿®å¤
- `AllTrackedMemoryView.xaml` - æ³¨é‡Šæ›´æ–°
- `UnityObjectsView.xaml` - æ³¨é‡Šæ›´æ–°

#### æ­¥éª¤ 1.2.2: æäº¤æˆ–æš‚å­˜
å¦‚æœç¼–è¯‘æˆåŠŸ:
```bash
git add .
git commit -m "refactor: Optimize SelectionDetails and update comments"
```

å¦‚æœæœ‰ç–‘é—®:
```bash
git stash save "WIP: Recent changes"
# ç¨åæ¢å¤: git stash pop
```

**é¢„è®¡æ—¶é—´**: 30 åˆ†é’Ÿ - 1 å°æ—¶


---

## ğŸ” é˜¶æ®µ 2: PathsToRoot æ·±åº¦å®ç° (3-5 å¤©)

### ä»»åŠ¡ 2.1: å®ç°å¼•ç”¨éå†ç®—æ³• ğŸŸ  HIGH

**ç›®æ ‡**: ä»é€‰ä¸­å¯¹è±¡é€’å½’å‘ä¸ŠæŸ¥æ‰¾æ‰€æœ‰å¼•ç”¨è·¯å¾„,ç›´åˆ° GC Root

#### æ­¥éª¤ 2.1.1: åˆ›å»º PathsToRootBuilder.cs

```csharp
// Unity.MemoryProfiler.UI/Services/PathsToRootBuilder.cs
using System;
using System.Collections.Generic;
using Unity.MemoryProfiler.Editor;
using static Unity.MemoryProfiler.Editor.CachedSnapshot;

namespace Unity.MemoryProfiler.UI.Services
{
    /// <summary>
    /// PathsToRoot æ„å»ºå™¨
    /// å‚è€ƒ: Unity.MemoryProfiler.Editor.ObjectConnection.cs
    /// </summary>
    public class PathsToRootBuilder
    {
        private readonly CachedSnapshot _snapshot;
        private readonly int _maxDepth;
        private readonly int _maxPaths;
        
        public PathsToRootBuilder(CachedSnapshot snapshot, int maxDepth = 10, int maxPaths = 100)
        {
            _snapshot = snapshot ?? throw new ArgumentNullException(nameof(snapshot));
            _maxDepth = maxDepth;
            _maxPaths = maxPaths;
        }
        
        /// <summary>
        /// æ„å»º Referenced By è·¯å¾„æ ‘
        /// </summary>
        public List<ReferencePathNode> BuildReferencedBy(SourceIndex targetIndex)
        {
            var visited = new HashSet<SourceIndex>();
            var paths = new List<ReferencePathNode>();
            var pathCount = 0;
            
            BuildReferencedByRecursive(targetIndex, 0, visited, paths, ref pathCount);
            
            return paths;
        }
        
        private void BuildReferencedByRecursive(
            SourceIndex currentIndex,
            int depth,
            HashSet<SourceIndex> visited,
            List<ReferencePathNode> currentLevel,
            ref int pathCount)
        {
            // 1. æ·±åº¦é™åˆ¶
            if (depth >= _maxDepth)
                return;
            
            // 2. è·¯å¾„æ•°é‡é™åˆ¶
            if (pathCount >= _maxPaths)
                return;
            
            // 3. å¾ªç¯å¼•ç”¨æ£€æµ‹
            if (visited.Contains(currentIndex))
                return;
            
            visited.Add(currentIndex);
            
            // 4. è·å–æ‰€æœ‰å¼•ç”¨æ­¤å¯¹è±¡çš„å¯¹è±¡
            var referencers = GetReferencers(currentIndex);
            
            foreach (var referencer in referencers)
            {
                var node = new ReferencePathNode
                {
                    SourceIndex = referencer.From,
                    Name = GetObjectName(referencer.From),
                    Type = GetObjectType(referencer.From),
                    FieldName = GetFieldName(referencer),
                    Size = GetObjectSize(referencer.From),
                    IsGCRoot = IsGCRoot(referencer.From),
                    Depth = depth
                };
                
                currentLevel.Add(node);
                pathCount++;
                
                // 5. å¦‚æœä¸æ˜¯ GC Rootï¼Œç»§ç»­é€’å½’
                if (!node.IsGCRoot)
                {
                    node.Children = new List<ReferencePathNode>();
                    BuildReferencedByRecursive(
                        referencer.From,
                        depth + 1,
                        new HashSet<SourceIndex>(visited), // æ¯ä¸ªåˆ†æ”¯ç‹¬ç«‹çš„ visited
                        node.Children,
                        ref pathCount);
                }
            }
        }
        
        /// <summary>
        /// è·å–æ‰€æœ‰å¼•ç”¨æ­¤å¯¹è±¡çš„å¯¹è±¡
        /// å‚è€ƒ: Unity CachedSnapshot.Connections
        /// </summary>
        private List<ConnectionInfo> GetReferencers(SourceIndex targetIndex)
        {
            var referencers = new List<ConnectionInfo>();
            
            // Unity çš„ ObjectConnection å­˜å‚¨åœ¨ CrawledData.Connections
            // connections.from[] â†’ connections.to[] è¡¨ç¤º from å¼•ç”¨äº† to
            // æˆ‘ä»¬éœ€è¦åå‘æŸ¥æ‰¾: æ‰€æœ‰ to == targetIndex çš„ from
            
            var connections = _snapshot.CrawledData.Connections;
            
            for (int i = 0; i < connections.ManagedObjectsConnectedToArray.Length; i++)
            {
                var toIndex = connections.ManagedObjectsConnectedToArray[i];
                if (toIndex == targetIndex.Index && targetIndex.Id == SourceIndex.SourceId.ManagedObject)
                {
                    var fromIndex = connections.ManagedObjectsConnectedFromArray[i];
                    var fromSourceIndex = new SourceIndex(SourceIndex.SourceId.ManagedObject, fromIndex);
                    
                    referencers.Add(new ConnectionInfo
                    {
                        From = fromSourceIndex,
                        To = targetIndex,
                        FieldIndex = connections.ManagedObjectsConnectionsFieldIndexArray[i],
                        ArrayIndex = connections.ManagedObjectsConnectionsArrayIndexArray[i]
                    });
                }
            }
            
            // TODO: å¤„ç† NativeObjects â†’ ManagedObjects å¼•ç”¨
            // TODO: å¤„ç† Static Fields å¼•ç”¨
            
            return referencers;
        }
        
        /// <summary>
        /// åˆ¤æ–­æ˜¯å¦ä¸º GC Root
        /// å‚è€ƒ: Unity ObjectConnection.IsGCRoot
        /// </summary>
        private bool IsGCRoot(SourceIndex index)
        {
            // GC Root ç±»å‹:
            // 1. é™æ€å­—æ®µ (Static Fields)
            // 2. å…¨å±€å˜é‡ (Global Variables)
            // 3. æ ˆå¼•ç”¨ (Stack References)
            // 4. çº¿ç¨‹å±€éƒ¨å­˜å‚¨ (Thread Local Storage)
            
            if (index.Id == SourceIndex.SourceId.ManagedObject)
            {
                var objectIndex = index.Index;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨ GCHandles ä¸­
                if (_snapshot.CrawledData.GCHandles.Target.Contains(objectIndex))
                    return true;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºé™æ€å­—æ®µ
                foreach (var typeIndex in _snapshot.TypeDescriptions.TypeIndex)
                {
                    var staticFieldBytes = _snapshot.TypeDescriptions.StaticFieldBytes[typeIndex];
                    if (staticFieldBytes != null && staticFieldBytes.Length > 0)
                    {
                        // TODO: è§£æé™æ€å­—æ®µå¹¶æ£€æŸ¥æ˜¯å¦å¼•ç”¨æ­¤å¯¹è±¡
                        // è¿™éœ€è¦æ·±å…¥è§£æ TypeDescription å’Œ FieldDescription
                    }
                }
            }
            
            return false;
        }
        
        private string GetObjectName(SourceIndex index)
        {
            if (index.Id == SourceIndex.SourceId.NativeObject)
            {
                var nativeIndex = index.Index;
                if (nativeIndex >= 0 && nativeIndex < _snapshot.NativeObjects.Count)
                {
                    return _snapshot.NativeObjects.ObjectName[nativeIndex];
                }
            }
            else if (index.Id == SourceIndex.SourceId.ManagedObject)
            {
                var managedIndex = index.Index;
                if (managedIndex >= 0 && managedIndex < _snapshot.CrawledData.ManagedObjects.Count)
                {
                    var managedObject = _snapshot.CrawledData.ManagedObjects[managedIndex];
                    var typeIndex = managedObject.ITypeDescription;
                    return _snapshot.TypeDescriptions.TypeDescriptionName[typeIndex];
                }
            }
            
            return "<Unknown>";
        }
        
        private string GetObjectType(SourceIndex index)
        {
            if (index.Id == SourceIndex.SourceId.NativeObject)
            {
                var nativeIndex = index.Index;
                if (nativeIndex >= 0 && nativeIndex < _snapshot.NativeObjects.Count)
                {
                    var typeIndex = _snapshot.NativeObjects.NativeTypeArrayIndex[nativeIndex];
                    return _snapshot.NativeTypes.TypeName[typeIndex];
                }
            }
            else if (index.Id == SourceIndex.SourceId.ManagedObject)
            {
                var managedIndex = index.Index;
                if (managedIndex >= 0 && managedIndex < _snapshot.CrawledData.ManagedObjects.Count)
                {
                    var managedObject = _snapshot.CrawledData.ManagedObjects[managedIndex];
                    var typeIndex = managedObject.ITypeDescription;
                    return _snapshot.TypeDescriptions.TypeDescriptionName[typeIndex];
                }
            }
            
            return "<Unknown>";
        }
        
        private string GetFieldName(ConnectionInfo connection)
        {
            if (connection.FieldIndex >= 0)
            {
                // è·å–å­—æ®µåç§°
                // éœ€è¦é€šè¿‡ FieldDescription è§£æ
                return $"field_{connection.FieldIndex}";
            }
            else if (connection.ArrayIndex >= 0)
            {
                return $"[{connection.ArrayIndex}]";
            }
            
            return string.Empty;
        }
        
        private long GetObjectSize(SourceIndex index)
        {
            if (index.Id == SourceIndex.SourceId.NativeObject)
            {
                var nativeIndex = index.Index;
                if (nativeIndex >= 0 && nativeIndex < _snapshot.NativeObjects.Count)
                {
                    return _snapshot.NativeObjects.Size[nativeIndex];
                }
            }
            else if (index.Id == SourceIndex.SourceId.ManagedObject)
            {
                var managedIndex = index.Index;
                if (managedIndex >= 0 && managedIndex < _snapshot.CrawledData.ManagedObjects.Count)
                {
                    return _snapshot.CrawledData.ManagedObjects[managedIndex].Size;
                }
            }
            
            return 0;
        }
        
        private struct ConnectionInfo
        {
            public SourceIndex From;
            public SourceIndex To;
            public int FieldIndex;
            public int ArrayIndex;
        }
    }
    
    /// <summary>
    /// å¼•ç”¨è·¯å¾„èŠ‚ç‚¹
    /// </summary>
    public class ReferencePathNode
    {
        public SourceIndex SourceIndex { get; set; }
        public string Name { get; set; }
        public string Type { get; set; }
        public string FieldName { get; set; }
        public long Size { get; set; }
        public bool IsGCRoot { get; set; }
        public int Depth { get; set; }
        public List<ReferencePathNode> Children { get; set; }
    }
}
```

**é¢„è®¡æ—¶é—´**: 1-2 å¤©

---

#### æ­¥éª¤ 2.1.2: æ›´æ–° PathsToRootView UI

```xml
<!-- Unity.MemoryProfiler.UI/Controls/PathsToRootView.xaml -->
<UserControl>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <!-- æ ‡é¢˜æ  -->
        <Border Grid.Row="0" Background="#F5F5F5" Padding="10,5">
            <TextBlock Text="References" FontWeight="SemiBold" FontSize="14"/>
        </Border>
        
        <!-- å¼•ç”¨æ ‘ -->
        <dxg:TreeListControl 
            Grid.Row="1"
            x:Name="ReferencesTree"
            ItemsSource="{Binding ReferencePaths}"
            AutoExpandAllNodes="False"
            ShowBorder="False">
            
            <dxg:TreeListControl.Columns>
                <dxg:TreeListColumn FieldName="Name" Header="Name" Width="*">
                    <dxg:TreeListColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <!-- GC Root å›¾æ ‡ -->
                                <Image Source="/Icons/GCRoot.png" Width="16" Height="16" 
                                       Visibility="{Binding Row.IsGCRoot, Converter={StaticResource BoolToVisibilityConverter}}"
                                       Margin="0,0,5,0"/>
                                <TextBlock Text="{Binding Row.Name}" VerticalAlignment="Center"/>
                                <!-- å­—æ®µåç§° -->
                                <TextBlock Text="{Binding Row.FieldName, StringFormat=' â†’ {0}'}" 
                                           Foreground="Gray" VerticalAlignment="Center"
                                           Visibility="{Binding Row.FieldName, Converter={StaticResource NullToVisibilityConverter}}"/>
                            </StackPanel>
                        </DataTemplate>
                    </dxg:TreeListColumn.CellTemplate>
                </dxg:TreeListColumn>
                <dxg:TreeListColumn FieldName="Type" Header="Type" Width="200"/>
                <dxg:TreeListColumn FieldName="SizeFormatted" Header="Size" Width="100"/>
            </dxg:TreeListControl.Columns>
            
            <dxg:TreeListControl.View>
                <dxg:TreeListView 
                    ChildNodesPath="Children"
                    NavigationStyle="Row"
                    AllowEditing="False"/>
            </dxg:TreeListControl.View>
        </dxg:TreeListControl>
    </Grid>
</UserControl>
```

```csharp
// Unity.MemoryProfiler.UI/Controls/PathsToRootView.xaml.cs
public partial class PathsToRootView : UserControl
{
    public static readonly DependencyProperty ReferencePathsProperty =
        DependencyProperty.Register(
            nameof(ReferencePaths),
            typeof(ObservableCollection<ReferencePathNode>),
            typeof(PathsToRootView),
            new PropertyMetadata(null));
    
    public ObservableCollection<ReferencePathNode> ReferencePaths
    {
        get => (ObservableCollection<ReferencePathNode>)GetValue(ReferencePathsProperty);
        set => SetValue(ReferencePathsProperty, value);
    }
    
    public PathsToRootView()
    {
        InitializeComponent();
        ReferencePaths = new ObservableCollection<ReferencePathNode>();
    }
    
    public void LoadReferences(CachedSnapshot snapshot, SourceIndex targetIndex)
    {
        ReferencePaths.Clear();
        
        var builder = new PathsToRootBuilder(snapshot, maxDepth: 10, maxPaths: 100);
        var paths = builder.BuildReferencedBy(targetIndex);
        
        foreach (var path in paths)
        {
            ReferencePaths.Add(path);
        }
    }
}
```

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

#### æ­¥éª¤ 2.1.3: é›†æˆåˆ° SelectionDetailsPanel

```csharp
// Unity.MemoryProfiler.UI/Controls/SelectionDetailsPanel.xaml.cs

public void ShowManagedObjectDetails(CachedSnapshot snapshot, int managedObjectIndex)
{
    // ... åŸæœ‰é€»è¾‘ ...
    
    // æ˜¾ç¤º References (PathsToRoot)
    ReferencesExpander.Visibility = Visibility.Visible;
    ReferencesExpander.IsExpanded = true;
    
    var sourceIndex = new SourceIndex(SourceIndex.SourceId.ManagedObject, managedObjectIndex);
    PathsToRootViewControl.LoadReferences(snapshot, sourceIndex);
}

public void ShowNativeObjectDetails(CachedSnapshot snapshot, int nativeObjectIndex)
{
    // ... åŸæœ‰é€»è¾‘ ...
    
    // æ˜¾ç¤º References
    ReferencesExpander.Visibility = Visibility.Visible;
    ReferencesExpander.IsExpanded = true;
    
    var sourceIndex = new SourceIndex(SourceIndex.SourceId.NativeObject, nativeObjectIndex);
    PathsToRootViewControl.LoadReferences(snapshot, sourceIndex);
}
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

### ä»»åŠ¡ 2.2: æµ‹è¯•å’Œä¼˜åŒ– PathsToRoot

#### æ­¥éª¤ 2.2.1: åˆ›å»ºæµ‹è¯•å¿«ç…§
- åœ¨ Unity ä¸­åˆ›å»ºå¤æ‚å¼•ç”¨å…³ç³»çš„åœºæ™¯
- æ•è·å¿«ç…§
- åœ¨ WPF å·¥å…·ä¸­æ‰“å¼€

#### æ­¥éª¤ 2.2.2: å¯¹æ¯”éªŒè¯
- åœ¨ Unity Memory Profiler ä¸­æŸ¥çœ‹åŒä¸€å¯¹è±¡çš„ PathsToRoot
- åœ¨ WPF å·¥å…·ä¸­æŸ¥çœ‹
- å¯¹æ¯”è·¯å¾„æ˜¯å¦ä¸€è‡´

#### æ­¥éª¤ 2.2.3: æ€§èƒ½ä¼˜åŒ–
- å¦‚æœè·¯å¾„æ•°é‡è¿‡å¤š (>1000),æ·»åŠ åˆ†é¡µ
- å¦‚æœé€’å½’æ·±åº¦è¿‡å¤§,æ·»åŠ æ·±åº¦é™åˆ¶æç¤º

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

## ğŸ” é˜¶æ®µ 3: å®Œå–„è¿‡æ»¤å’Œæœç´¢ (2-3 å¤©)

### ä»»åŠ¡ 3.1: å®ç°é«˜çº§è¿‡æ»¤å™¨ ğŸŸ  HIGH

#### æ­¥éª¤ 3.1.1: åˆ›å»º TreeFilter ç±»

```csharp
// Unity.MemoryProfiler.UI/Models/TreeFilter.cs
public class TreeFilter<TData> where TData : IFilterableData
{
    public string NamePattern { get; set; }
    public bool UseRegex { get; set; }
    public long MinSize { get; set; }
    public long MaxSize { get; set; }
    public List<string> TypeFilter { get; set; }
    public List<string> CategoryFilter { get; set; }
    
    public bool Matches(TreeNode<TData> node)
    {
        // 1. Name è¿‡æ»¤
        if (!string.IsNullOrEmpty(NamePattern))
        {
            if (UseRegex)
            {
                try
                {
                    if (!Regex.IsMatch(node.Data.Name, NamePattern, RegexOptions.IgnoreCase))
                        return false;
                }
                catch (Exception)
                {
                    return false;
                }
            }
            else
            {
                if (!node.Data.Name.Contains(NamePattern, StringComparison.OrdinalIgnoreCase))
                    return false;
            }
        }
        
        // 2. Size è¿‡æ»¤
        if (MinSize > 0 && node.Data.Size < MinSize)
            return false;
        if (MaxSize > 0 && node.Data.Size > MaxSize)
            return false;
        
        // 3. Type è¿‡æ»¤
        if (TypeFilter != null && TypeFilter.Count > 0)
        {
            if (!TypeFilter.Any(t => node.Data.Type.Contains(t, StringComparison.OrdinalIgnoreCase)))
                return false;
        }
        
        // 4. Category è¿‡æ»¤
        if (CategoryFilter != null && CategoryFilter.Count > 0)
        {
            if (!CategoryFilter.Any(c => node.Data.Category.Contains(c, StringComparison.OrdinalIgnoreCase)))
                return false;
        }
        
        return true;
    }
    
    public ObservableCollection<TreeNode<TData>> Apply(ObservableCollection<TreeNode<TData>> source)
    {
        var result = new ObservableCollection<TreeNode<TData>>();
        
        foreach (var node in source)
        {
            var filteredNode = ApplyRecursive(node);
            if (filteredNode != null)
                result.Add(filteredNode);
        }
        
        return result;
    }
    
    private TreeNode<TData> ApplyRecursive(TreeNode<TData> node)
    {
        // å¦‚æœå½“å‰èŠ‚ç‚¹åŒ¹é…,åŒ…å«æ‰€æœ‰å­èŠ‚ç‚¹
        if (Matches(node))
        {
            return node.Clone(); // æ·±æ‹·è´
        }
        
        // å¦‚æœå½“å‰èŠ‚ç‚¹ä¸åŒ¹é…,æ£€æŸ¥å­èŠ‚ç‚¹
        var filteredChildren = new List<TreeNode<TData>>();
        foreach (var child in node.Children)
        {
            var filteredChild = ApplyRecursive(child);
            if (filteredChild != null)
                filteredChildren.Add(filteredChild);
        }
        
        // å¦‚æœæœ‰å­èŠ‚ç‚¹åŒ¹é…,ä¿ç•™å½“å‰èŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹
        if (filteredChildren.Count > 0)
        {
            var clonedNode = node.CloneWithoutChildren();
            foreach (var child in filteredChildren)
                clonedNode.Children.Add(child);
            return clonedNode;
        }
        
        return null;
    }
}

public interface IFilterableData
{
    string Name { get; }
    string Type { get; }
    string Category { get; }
    long Size { get; }
}
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

#### æ­¥éª¤ 3.1.2: æ›´æ–° ViewModel æ·»åŠ è¿‡æ»¤é€»è¾‘

```csharp
// Unity.MemoryProfiler.UI/ViewModels/AllTrackedMemoryViewModel.cs

private TreeFilter<MemoryItemData> _filter;
private string _searchText;
private bool _useRegex;
private long _minSize;
private long _maxSize;

public string SearchText
{
    get => _searchText;
    set
    {
        if (SetProperty(ref _searchText, value))
            ApplyFilter();
    }
}

public bool UseRegex
{
    get => _useRegex;
    set
    {
        if (SetProperty(ref _useRegex, value))
            ApplyFilter();
    }
}

public long MinSize
{
    get => _minSize;
    set
    {
        if (SetProperty(ref _minSize, value))
            ApplyFilter();
    }
}

public long MaxSize
{
    get => _maxSize;
    set
    {
        if (SetProperty(ref _maxSize, value))
            ApplyFilter();
    }
}

public IRelayCommand ClearFilterCommand { get; }

private void ApplyFilter()
{
    if (Model == null)
        return;
    
    _filter = new TreeFilter<MemoryItemData>
    {
        NamePattern = SearchText,
        UseRegex = UseRegex,
        MinSize = MinSize,
        MaxSize = MaxSize
    };
    
    FilteredRootNodes = _filter.Apply(Model.RootNodes);
    OnPropertyChanged(nameof(FilteredResultCount));
}

public int FilteredResultCount
{
    get
    {
        int count = 0;
        CountNodesRecursive(FilteredRootNodes, ref count);
        return count;
    }
}

private void CountNodesRecursive(ObservableCollection<TreeNode<MemoryItemData>> nodes, ref int count)
{
    foreach (var node in nodes)
    {
        count++;
        if (node.Children != null)
            CountNodesRecursive(node.Children, ref count);
    }
}
```

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

#### æ­¥éª¤ 3.1.3: æ›´æ–° View æ·»åŠ è¿‡æ»¤é¢æ¿

```xml
<!-- Unity.MemoryProfiler.UI/Views/AllTrackedMemoryView.xaml -->

<Expander Header="Filter" IsExpanded="False" Margin="0,5,0,10">
    <StackPanel Margin="10">
        <!-- Name æœç´¢ -->
        <dxe:TextEdit
            EditValue="{Binding SearchText, UpdateSourceTrigger=PropertyChanged}"
            NullText="Search by name..."
            ClearButtonVisibility="Auto"
            ShowNullText="True"
            Margin="0,0,0,5"/>
        
        <!-- æ­£åˆ™è¡¨è¾¾å¼ -->
        <CheckBox Content="Use Regular Expression" IsChecked="{Binding UseRegex}" Margin="0,0,0,10"/>
        
        <!-- Size èŒƒå›´ -->
        <TextBlock Text="Size Range:" FontWeight="SemiBold" Margin="0,0,0,5"/>
        <Grid Margin="0,0,0,10">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>
            
            <dxe:SpinEdit 
                Grid.Column="0"
                Value="{Binding MinSize}"
                MinValue="0"
                MaxValue="{Binding MaxSize}"
                AllowNullInput="True"
                NullText="Min Size (bytes)"/>
            
            <TextBlock Grid.Column="1" Text=" - " VerticalAlignment="Center" Margin="5,0"/>
            
            <dxe:SpinEdit 
                Grid.Column="2"
                Value="{Binding MaxSize}"
                MinValue="{Binding MinSize}"
                AllowNullInput="True"
                NullText="Max Size (bytes)"/>
        </Grid>
        
        <!-- ç»“æœç»Ÿè®¡ -->
        <TextBlock>
            <Run Text="Results: "/>
            <Run Text="{Binding FilteredResultCount}" FontWeight="SemiBold"/>
            <Run Text=" items"/>
        </TextBlock>
        
        <!-- æ¸…é™¤æŒ‰é’® -->
        <Button Content="Clear Filter" Command="{Binding ClearFilterCommand}" Margin="0,10,0,0"/>
    </StackPanel>
</Expander>
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

#### æ­¥éª¤ 3.1.4: åŒæ ·æ›´æ–° UnityObjectsView

(é‡å¤ä¸Šè¿°æ­¥éª¤)

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

## ğŸ—ºï¸ é˜¶æ®µ 4: Memory Map è§†å›¾ (3-4 å¤©)

### ä»»åŠ¡ 4.1: åˆ›å»º MemoryMapView åŸºç¡€ç»“æ„ ğŸŸ¡ MEDIUM

#### æ­¥éª¤ 4.1.1: åˆ›å»º MemoryMapViewModel

```csharp
// Unity.MemoryProfiler.UI/ViewModels/MemoryMapViewModel.cs
public class MemoryMapViewModel : ViewModelBase
{
    private ObservableCollection<MemoryRegionBlock> _regions;
    private MemoryRegionBlock _selectedRegion;
    private double _zoomLevel = 1.0;
    private CachedSnapshot _currentSnapshot;
    
    public ObservableCollection<MemoryRegionBlock> Regions
    {
        get => _regions;
        set => SetProperty(ref _regions, value);
    }
    
    public MemoryRegionBlock SelectedRegion
    {
        get => _selectedRegion;
        set => SetProperty(ref _selectedRegion, value);
    }
    
    public double ZoomLevel
    {
        get => _zoomLevel;
        set => SetProperty(ref _zoomLevel, Math.Max(0.1, Math.Min(10.0, value)));
    }
    
    public IRelayCommand ZoomInCommand { get; }
    public IRelayCommand ZoomOutCommand { get; }
    public IRelayCommand ResetZoomCommand { get; }
    
    public MemoryMapViewModel()
    {
        Regions = new ObservableCollection<MemoryRegionBlock>();
        ZoomInCommand = new RelayCommand(() => ZoomLevel *= 1.2);
        ZoomOutCommand = new RelayCommand(() => ZoomLevel /= 1.2);
        ResetZoomCommand = new RelayCommand(() => ZoomLevel = 1.0);
    }
    
    public void LoadSnapshot(CachedSnapshot snapshot)
    {
        _currentSnapshot = snapshot ?? throw new ArgumentNullException(nameof(snapshot));
        Regions.Clear();
        
        // éå†æ‰€æœ‰å†…å­˜åŒºåŸŸ
        var builder = new MemoryMapModelBuilder();
        var model = builder.Build(snapshot);
        
        foreach (var region in model.Regions)
        {
            Regions.Add(region);
        }
    }
}

public class MemoryRegionBlock
{
    public ulong StartAddress { get; set; }
    public ulong Size { get; set; }
    public string Name { get; set; }
    public MemoryRegionCategory Category { get; set; }
    public string CategoryName => Category.ToString();
    public string SizeFormatted => FormatBytes(Size);
    public string AddressRange => $"0x{StartAddress:X16} - 0x{(StartAddress + Size):X16}";
    
    // UI å±æ€§
    public double X { get; set; }
    public double Y { get; set; }
    public double Width { get; set; }
    public double Height { get; set; }
    public Brush Color { get; set; }
}

public enum MemoryRegionCategory
{
    Native,
    Managed,
    Graphics,
    Executable,
    Reserved,
    Untracked
}
```

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

#### æ­¥éª¤ 4.1.2: åˆ›å»º MemoryMapView UI

```xml
<!-- Unity.MemoryProfiler.UI/Views/MemoryMapView.xaml -->
<UserControl>
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <!-- Toolbar -->
            <RowDefinition Height="*"/>    <!-- Canvas -->
            <RowDefinition Height="200"/>  <!-- Details -->
        </Grid.RowDefinitions>
        
        <!-- Toolbar -->
        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="5">
            <Button Content="Zoom In" Command="{Binding ZoomInCommand}" Margin="0,0,5,0"/>
            <Button Content="Zoom Out" Command="{Binding ZoomOutCommand}" Margin="0,0,5,0"/>
            <Button Content="Reset" Command="{Binding ResetZoomCommand}" Margin="0,0,10,0"/>
            <TextBlock Text="{Binding ZoomLevel, StringFormat=Zoom: {0:P0}}" VerticalAlignment="Center"/>
        </StackPanel>
        
        <!-- Memory Map Canvas -->
        <ScrollViewer Grid.Row="1" HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Auto">
            <Canvas x:Name="MemoryMapCanvas" Background="White">
                <!-- å†…å­˜åŒºå—å°†åŠ¨æ€ç”Ÿæˆ -->
            </Canvas>
        </ScrollViewer>
        
        <!-- Selected Region Details -->
        <Expander Grid.Row="2" Header="Region Details" IsExpanded="True">
            <Grid DataContext="{Binding SelectedRegion}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="120"/>
                    <ColumnDefinition Width="*"/>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                </Grid.RowDefinitions>
                
                <TextBlock Grid.Row="0" Grid.Column="0" Text="Name:" FontWeight="SemiBold"/>
                <TextBlock Grid.Row="0" Grid.Column="1" Text="{Binding Name}"/>
                
                <TextBlock Grid.Row="1" Grid.Column="0" Text="Category:" FontWeight="SemiBold"/>
                <TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding CategoryName}"/>
                
                <TextBlock Grid.Row="2" Grid.Column="0" Text="Address Range:" FontWeight="SemiBold"/>
                <TextBlock Grid.Row="2" Grid.Column="1" Text="{Binding AddressRange}"/>
                
                <TextBlock Grid.Row="3" Grid.Column="0" Text="Size:" FontWeight="SemiBold"/>
                <TextBlock Grid.Row="3" Grid.Column="1" Text="{Binding SizeFormatted}"/>
            </Grid>
        </Expander>
    </Grid>
</UserControl>
```

```csharp
// Unity.MemoryProfiler.UI/Views/MemoryMapView.xaml.cs
public partial class MemoryMapView : UserControl
{
    public MemoryMapView()
    {
        InitializeComponent();
        DataContextChanged += OnDataContextChanged;
    }
    
    private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
    {
        if (e.NewValue is MemoryMapViewModel viewModel)
        {
            viewModel.PropertyChanged += ViewModel_PropertyChanged;
            RenderMemoryMap(viewModel);
        }
    }
    
    private void ViewModel_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(MemoryMapViewModel.Regions) ||
            e.PropertyName == nameof(MemoryMapViewModel.ZoomLevel))
        {
            RenderMemoryMap(sender as MemoryMapViewModel);
        }
    }
    
    private void RenderMemoryMap(MemoryMapViewModel viewModel)
    {
        if (viewModel == null || viewModel.Regions == null)
            return;
        
        MemoryMapCanvas.Children.Clear();
        
        // è®¡ç®—å¸ƒå±€
        var layout = CalculateLayout(viewModel.Regions, MemoryMapCanvas.ActualWidth, viewModel.ZoomLevel);
        
        foreach (var region in layout)
        {
            var rect = new Rectangle
            {
                Width = region.Width,
                Height = region.Height,
                Fill = region.Color,
                Stroke = Brushes.Black,
                StrokeThickness = 1,
                Tag = region
            };
            
            Canvas.SetLeft(rect, region.X);
            Canvas.SetTop(rect, region.Y);
            
            rect.MouseEnter += Region_MouseEnter;
            rect.MouseLeave += Region_MouseLeave;
            rect.MouseLeftButtonDown += Region_MouseLeftButtonDown;
            
            MemoryMapCanvas.Children.Add(rect);
            
            // æ·»åŠ æ ‡ç­¾
            if (region.Width > 50 && region.Height > 20)
            {
                var label = new TextBlock
                {
                    Text = region.Name,
                    Foreground = Brushes.White,
                    FontSize = 10,
                    FontWeight = FontWeights.SemiBold
                };
                
                Canvas.SetLeft(label, region.X + 5);
                Canvas.SetTop(label, region.Y + 5);
                
                MemoryMapCanvas.Children.Add(label);
            }
        }
    }
    
    private List<MemoryRegionBlock> CalculateLayout(
        ObservableCollection<MemoryRegionBlock> regions,
        double canvasWidth,
        double zoomLevel)
    {
        var layout = new List<MemoryRegionBlock>();
        
        // 1. è®¡ç®—åœ°å€ç©ºé—´èŒƒå›´
        ulong minAddress = regions.Min(r => r.StartAddress);
        ulong maxAddress = regions.Max(r => r.StartAddress + r.Size);
        ulong totalRange = maxAddress - minAddress;
        
        // 2. è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
        double pixelPerByte = (canvasWidth * zoomLevel) / (double)totalRange;
        
        // 3. å¸ƒå±€åŒºå—
        double currentY = 10;
        double rowHeight = 40;
        
        foreach (var region in regions.OrderBy(r => r.StartAddress))
        {
            var block = new MemoryRegionBlock
            {
                StartAddress = region.StartAddress,
                Size = region.Size,
                Name = region.Name,
                Category = region.Category,
                X = (region.StartAddress - minAddress) * pixelPerByte,
                Y = currentY,
                Width = Math.Max(1, region.Size * pixelPerByte),
                Height = rowHeight,
                Color = GetCategoryColor(region.Category)
            };
            
            layout.Add(block);
            currentY += rowHeight + 5;
        }
        
        // æ›´æ–° Canvas é«˜åº¦
        MemoryMapCanvas.Height = currentY + 10;
        
        return layout;
    }
    
    private Brush GetCategoryColor(MemoryRegionCategory category)
    {
        return category switch
        {
            MemoryRegionCategory.Native => new SolidColorBrush(Color.FromRgb(41, 128, 185)),
            MemoryRegionCategory.Managed => new SolidColorBrush(Color.FromRgb(39, 174, 96)),
            MemoryRegionCategory.Graphics => new SolidColorBrush(Color.FromRgb(230, 126, 34)),
            MemoryRegionCategory.Executable => new SolidColorBrush(Color.FromRgb(142, 68, 173)),
            MemoryRegionCategory.Reserved => new SolidColorBrush(Color.FromRgb(149, 165, 166)),
            MemoryRegionCategory.Untracked => new SolidColorBrush(Color.FromRgb(231, 76, 60)),
            _ => Brushes.Gray
        };
    }
    
    private void Region_MouseEnter(object sender, MouseEventArgs e)
    {
        if (sender is Rectangle rect)
        {
            rect.Opacity = 0.7;
            
            // æ˜¾ç¤º Tooltip
            var region = rect.Tag as MemoryRegionBlock;
            rect.ToolTip = $"{region.Name}\n{region.AddressRange}\n{region.SizeFormatted}";
        }
    }
    
    private void Region_MouseLeave(object sender, MouseEventArgs e)
    {
        if (sender is Rectangle rect)
        {
            rect.Opacity = 1.0;
        }
    }
    
    private void Region_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (sender is Rectangle rect && DataContext is MemoryMapViewModel viewModel)
        {
            viewModel.SelectedRegion = rect.Tag as MemoryRegionBlock;
        }
    }
}
```

**é¢„è®¡æ—¶é—´**: 2 å¤©

---

#### æ­¥éª¤ 4.1.3: åˆ›å»º MemoryMapModelBuilder

```csharp
// Unity.MemoryProfiler.UI/Models/MemoryMapModelBuilder.cs
public class MemoryMapModelBuilder
{
    public MemoryMapModel Build(CachedSnapshot snapshot)
    {
        var regions = new List<MemoryRegionBlock>();
        
        // 1. Native Memory Regions
        for (int i = 0; i < snapshot.NativeMemoryRegions.Count; i++)
        {
            var region = snapshot.NativeMemoryRegions[i];
            regions.Add(new MemoryRegionBlock
            {
                StartAddress = region.AddressBase,
                Size = region.AddressSize,
                Name = region.Name ?? $"Region {i}",
                Category = DetermineCategory(region, snapshot)
            });
        }
        
        return new MemoryMapModel
        {
            Regions = regions
        };
    }
    
    private MemoryRegionCategory DetermineCategory(NativeMemoryRegionEntry region, CachedSnapshot snapshot)
    {
        // æ ¹æ®åŒºåŸŸåç§°æˆ–å±æ€§åˆ¤æ–­ç±»åˆ«
        if (region.Name.Contains("Managed", StringComparison.OrdinalIgnoreCase))
            return MemoryRegionCategory.Managed;
        if (region.Name.Contains("GfX", StringComparison.OrdinalIgnoreCase) ||
            region.Name.Contains("Graphics", StringComparison.OrdinalIgnoreCase))
            return MemoryRegionCategory.Graphics;
        if (region.Name.Contains("Executable", StringComparison.OrdinalIgnoreCase) ||
            region.Name.Contains("Code", StringComparison.OrdinalIgnoreCase))
            return MemoryRegionCategory.Executable;
        if (region.Name.Contains("Reserved", StringComparison.OrdinalIgnoreCase))
            return MemoryRegionCategory.Reserved;
        
        return MemoryRegionCategory.Native;
    }
}
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

### ä»»åŠ¡ 4.2: å°† MemoryMapView é›†æˆåˆ°ä¸»çª—å£

#### æ­¥éª¤ 4.2.1: æ·»åŠ  Memory Map æ ‡ç­¾é¡µ

```xml
<!-- Unity.MemoryProfiler.UI/MainWindow.xaml -->
<TabControl x:Name="MainTabControl">
    <TabItem Header="Summary">...</TabItem>
    <TabItem Header="Unity Objects">...</TabItem>
    <TabItem Header="All Of Memory">...</TabItem>
    <TabItem Header="Memory Map">
        <views:MemoryMapView DataContext="{Binding MemoryMapViewModel}"/>
    </TabItem>
</TabControl>
```

#### æ­¥éª¤ 4.2.2: æ›´æ–° MainWindow.xaml.cs

```csharp
public MemoryMapViewModel MemoryMapViewModel { get; }

public MainWindow()
{
    // ...
    MemoryMapViewModel = new MemoryMapViewModel();
}

private async Task LoadSnapshotAsync()
{
    // ...
    MemoryMapViewModel.LoadSnapshot(_currentSnapshot);
}
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

## ğŸ¨ é˜¶æ®µ 5: UI/UX ä¼˜åŒ– (2-3 å¤©)

### ä»»åŠ¡ 5.1: ç»Ÿä¸€æ ·å¼å’Œä¸»é¢˜ ğŸŸ¡ MEDIUM

#### æ­¥éª¤ 5.1.1: åˆ›å»ºç»Ÿä¸€çš„ ResourceDictionary

```xml
<!-- Unity.MemoryProfiler.UI/Themes/UnityProfilerTheme.xaml -->
<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
    
    <!-- Color Palette (Unity Dark Theme) -->
    <Color x:Key="BackgroundColor">#1E1E1E</Color>
    <Color x:Key="SurfaceColor">#252525</Color>
    <Color x:Key="PrimaryColor">#3A9BDC</Color>
    <Color x:Key="AccentColor">#FF6200</Color>
    <Color x:Key="TextPrimaryColor">#D4D4D4</Color>
    <Color x:Key="TextSecondaryColor">#969696</Color>
    <Color x:Key="BorderColor">#3F3F46</Color>
    
    <SolidColorBrush x:Key="BackgroundBrush" Color="{StaticResource BackgroundColor}"/>
    <SolidColorBrush x:Key="SurfaceBrush" Color="{StaticResource SurfaceColor}"/>
    <SolidColorBrush x:Key="PrimaryBrush" Color="{StaticResource PrimaryColor}"/>
    <SolidColorBrush x:Key="AccentBrush" Color="{StaticResource AccentColor}"/>
    <SolidColorBrush x:Key="TextPrimaryBrush" Color="{StaticResource TextPrimaryColor}"/>
    <SolidColorBrush x:Key="TextSecondaryBrush" Color="{StaticResource TextSecondaryColor}"/>
    <SolidColorBrush x:Key="BorderBrush" Color="{StaticResource BorderColor}"/>
    
    <!-- Typography -->
    <FontFamily x:Key="PrimaryFontFamily">Segoe UI</FontFamily>
    <FontFamily x:Key="MonospaceFontFamily">Consolas</FontFamily>
    
    <!-- Spacing -->
    <Thickness x:Key="SmallMargin">5</Thickness>
    <Thickness x:Key="MediumMargin">10</Thickness>
    <Thickness x:Key="LargeMargin">20</Thickness>
    
    <Thickness x:Key="SmallPadding">5</Thickness>
    <Thickness x:Key="MediumPadding">10</Thickness>
    <Thickness x:Key="LargePadding">20</Thickness>
    
    <!-- TextBlock Styles -->
    <Style x:Key="HeaderTextBlockStyle" TargetType="TextBlock">
        <Setter Property="FontSize" Value="18"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="Margin" Value="{StaticResource MediumMargin}"/>
    </Style>
    
    <Style x:Key="SubHeaderTextBlockStyle" TargetType="TextBlock">
        <Setter Property="FontSize" Value="14"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        <Setter Property="Foreground" Value="{StaticResource TextPrimaryBrush}"/>
        <Setter Property="Margin" Value="{StaticResource SmallMargin}"/>
    </Style>
    
    <!-- Button Styles -->
    <Style x:Key="PrimaryButtonStyle" TargetType="Button">
        <Setter Property="Background" Value="{StaticResource PrimaryBrush}"/>
        <Setter Property="Foreground" Value="White"/>
        <Setter Property="Padding" Value="15,8"/>
        <Setter Property="BorderThickness" Value="0"/>
        <Setter Property="FontWeight" Value="SemiBold"/>
        <Setter Property="Cursor" Value="Hand"/>
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="Button">
                    <Border Background="{TemplateBinding Background}"
                            CornerRadius="4"
                            Padding="{TemplateBinding Padding}">
                        <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                    </Border>
                    <ControlTemplate.Triggers>
                        <Trigger Property="IsMouseOver" Value="True">
                            <Setter Property="Opacity" Value="0.8"/>
                        </Trigger>
                        <Trigger Property="IsPressed" Value="True">
                            <Setter Property="Opacity" Value="0.6"/>
                        </Trigger>
                    </ControlTemplate.Triggers>
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
    
    <!-- ... æ›´å¤šæ ·å¼ ... -->
</ResourceDictionary>
```

#### æ­¥éª¤ 5.1.2: åœ¨ App.xaml ä¸­å¼•ç”¨

```xml
<Application.Resources>
    <ResourceDictionary>
        <ResourceDictionary.MergedDictionaries>
            <ResourceDictionary Source="Themes/UnityProfilerTheme.xaml"/>
        </ResourceDictionary.MergedDictionaries>
    </ResourceDictionary>
</Application.Resources>
```

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

### ä»»åŠ¡ 5.2: æ·»åŠ äº¤äº’ç»†èŠ‚ ğŸŸ¡ MEDIUM

#### æ­¥éª¤ 5.2.1: æ·»åŠ å³é”®èœå•

```xml
<!-- Unity.MemoryProfiler.UI/Views/UnityObjectsView.xaml -->
<dxg:TreeListControl>
    <dxg:TreeListControl.ContextMenu>
        <ContextMenu>
            <MenuItem Header="Copy Name" Command="{Binding CopyNameCommand}"/>
            <MenuItem Header="Copy Type" Command="{Binding CopyTypeCommand}"/>
            <Separator/>
            <MenuItem Header="Expand All" Command="{Binding ExpandAllCommand}"/>
            <MenuItem Header="Collapse All" Command="{Binding CollapseAllCommand}"/>
        </ContextMenu>
    </dxg:TreeListControl.ContextMenu>
</dxg:TreeListControl>
```

```csharp
// Unity.MemoryProfiler.UI/ViewModels/UnityObjectsViewModel.cs
public IRelayCommand CopyNameCommand { get; }
public IRelayCommand CopyTypeCommand { get; }

private void CopyName()
{
    if (SelectedNode != null)
    {
        Clipboard.SetText(SelectedNode.Data.Name);
    }
}

private void CopyType()
{
    if (SelectedNode != null)
    {
        Clipboard.SetText(SelectedNode.Data.Type);
    }
}
```

**é¢„è®¡æ—¶é—´**: åŠå¤©

---

#### æ­¥éª¤ 5.2.2: ä¼˜åŒ– Tooltip

```xml
<!-- åœ¨æ¯ä¸ªè¡¨æ ¼åˆ—æ·»åŠ è¯¦ç»†çš„ Tooltip -->
<dxg:TreeListColumn FieldName="Size" Header="Size">
    <dxg:TreeListColumn.HeaderToolTip>
        <ToolTip>
            <StackPanel>
                <TextBlock Text="Total Size" FontWeight="SemiBold"/>
                <TextBlock Text="The total memory size including native and managed memory."/>
            </StackPanel>
        </ToolTip>
    </dxg:TreeListColumn.HeaderToolTip>
</dxg:TreeListColumn>
```

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

## ğŸ§ª é˜¶æ®µ 6: æµ‹è¯•å’Œæ–‡æ¡£ (2-3 å¤©)

### ä»»åŠ¡ 6.1: åŠŸèƒ½æµ‹è¯•

#### æµ‹è¯•æ¸…å•

- [ ] Summary è§†å›¾
  - [ ] Memory Usage æ˜¾ç¤ºæ­£ç¡®
  - [ ] Allocated Distribution æ•°æ®å‡†ç¡®
  - [ ] Managed Heap è®¡ç®—æ­£ç¡®
  - [ ] Top Unity Objects æ’åºæ­£ç¡®
  - [ ] å¯¹æ¯”æ¨¡å¼æ­£å¸¸
  - [ ] Normalized Toggle ç”Ÿæ•ˆ
  
- [ ] Unity Objects è§†å›¾
  - [ ] æ ‘å½¢å±•å¼€/æŠ˜å 
  - [ ] æ’åºåŠŸèƒ½
  - [ ] è¿‡æ»¤åŠŸèƒ½
  - [ ] å¯¹æ¯”æ¨¡å¼
  - [ ] SelectionDetails è”åŠ¨
  
- [ ] All Of Memory è§†å›¾
  - [ ] æ‰€æœ‰åˆ†ç»„æ˜¾ç¤ºå®Œæ•´
  - [ ] é’»å–åˆ°å…·ä½“å¯¹è±¡
  - [ ] è¿‡æ»¤åŠŸèƒ½
  - [ ] å¯¹æ¯”æ¨¡å¼
  
- [ ] Selection Details é¢æ¿
  - [ ] Basic Info æ˜¾ç¤º
  - [ ] Managed Object Inspector
  - [ ] PathsToRoot å®Œæ•´è·¯å¾„
  - [ ] References è·³è½¬
  
- [ ] Memory Map è§†å›¾
  - [ ] åœ°å€ç©ºé—´å¯è§†åŒ–
  - [ ] ç¼©æ”¾å’Œå¹³ç§»
  - [ ] åŒºåŸŸç‚¹å‡»é€‰æ‹©

**é¢„è®¡æ—¶é—´**: 1-2 å¤©

---

### ä»»åŠ¡ 6.2: æ€§èƒ½æµ‹è¯•

#### æµ‹è¯•åœºæ™¯

1. **å°å¿«ç…§** (< 100 MB)
   - åŠ è½½æ—¶é—´ < 5 ç§’
   - UI å“åº”æµç•…

2. **ä¸­å¿«ç…§** (100-500 MB)
   - åŠ è½½æ—¶é—´ < 30 ç§’
   - UI å¯æ¥å—

3. **å¤§å¿«ç…§** (500 MB - 1 GB)
   - åŠ è½½æ—¶é—´ < 2 åˆ†é’Ÿ
   - UI å¯ç”¨

4. **è¶…å¤§å¿«ç…§** (> 1 GB)
   - åŠ è½½æ—¶é—´ < 5 åˆ†é’Ÿ
   - ä¼˜åŒ–å»ºè®®

**é¢„è®¡æ—¶é—´**: 1 å¤©

---

### ä»»åŠ¡ 6.3: ç¼–å†™æ–‡æ¡£

#### æ–‡æ¡£åˆ—è¡¨

1. **ç”¨æˆ·æ‰‹å†Œ** (`ç”¨æˆ·æ‰‹å†Œ.md`)
   - å®‰è£…æŒ‡å—
   - å¿«é€Ÿå…¥é—¨
   - åŠŸèƒ½è¯¦è§£
   - å¸¸è§é—®é¢˜

2. **å¼€å‘è€…æ–‡æ¡£** (`å¼€å‘è€…æ–‡æ¡£.md`)
   - æ¶æ„è®¾è®¡
   - ä»£ç è§„èŒƒ
   - æ‰©å±•æŒ‡å—

3. **API æ–‡æ¡£** (XML æ³¨é‡Š + Sandcastle)
   - æ ¸å¿ƒç±» API
   - ModelBuilder API
   - Service API

**é¢„è®¡æ—¶é—´**: 1-2 å¤©

---

## ğŸ“ˆ é‡Œç¨‹ç¢‘æ—¶é—´è¡¨

| é‡Œç¨‹ç¢‘ | ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | ç´¯è®¡æ—¶é—´ |
|--------|------|---------|----------|
| M0: çŠ¶æ€ç¡®è®¤ | âœ… TreeListView å·²è¿ç§» | âœ… å·²å®Œæˆ | 0 å¤© |
| M1: éªŒè¯å’Œä¿®å¤å®Œæˆ | éªŒè¯ç¼–è¯‘ + å¤„ç†æœªæäº¤ä¿®æ”¹ | 1 å¤© | 1 å¤© |
| M2: PathsToRoot å®Œæˆ | æ·±åº¦å®ç°å¼•ç”¨éå† | 3-5 å¤© | 6 å¤© |
| M3: è¿‡æ»¤/æœç´¢å®Œæˆ | é«˜çº§è¿‡æ»¤å™¨ | 2-3 å¤© | 9 å¤© |
| M4: Memory Map å®Œæˆ | æ–°è§†å›¾å®ç° | 3-4 å¤© | 13 å¤© |
| M5: UI/UX ä¼˜åŒ–å®Œæˆ | æ ·å¼ç»Ÿä¸€ + äº¤äº’ç»†èŠ‚ | 2-3 å¤© | 16 å¤© |
| M6: æµ‹è¯•å’Œæ–‡æ¡£å®Œæˆ | å…¨é¢æµ‹è¯• + æ–‡æ¡£ | 2-3 å¤© | 19 å¤© |

**æ€»é¢„è®¡æ—¶é—´**: 2.5-3.5 å‘¨ (13-19 ä¸ªå·¥ä½œæ—¥)

**æ—¶é—´èŠ‚çœ**: TreeListView è¿ç§»å·²å®Œæˆï¼ŒèŠ‚çœ 2-3 å¤©å·¥ä½œé‡ âœ…

---

## ğŸš¦ é£é™©ç®¡ç†

### é«˜é£é™©é¡¹

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| PathsToRoot ç®—æ³•å¤æ‚,å¯èƒ½å®ç°ä¸å®Œæ•´ | é«˜ | ä¸­ | åˆ†é˜¶æ®µå®ç°,å…ˆå®ç°åŸºç¡€ç‰ˆæœ¬ |
| å¤§å¿«ç…§åŠ è½½æ€§èƒ½å·® | ä¸­ | é«˜ | å¼‚æ­¥åŠ è½½ + åˆ†é¡µ |
| DevExpress æ§ä»¶å­¦ä¹ æ›²çº¿ | ä½ | ä¸­ | æŸ¥é˜…æ–‡æ¡£ + ç¤ºä¾‹ä»£ç  |

### ä¸­é£é™©é¡¹

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|----------|
| Unity.MemoryProfiler.Parser ç‰ˆæœ¬å…¼å®¹ | ä¸­ | ä½ | æµ‹è¯•å¤šä¸ª Unity ç‰ˆæœ¬çš„å¿«ç…§ |
| UI æ ·å¼ä¸ Unity ä¸ä¸€è‡´ | ä½ | é«˜ | å‚è€ƒ Unity Editor æˆªå›¾ |
| åŠŸèƒ½æµ‹è¯•è¦†ç›–ä¸å…¨ | ä¸­ | ä¸­ | åˆ›å»ºè¯¦ç»†æµ‹è¯•æ¸…å• |

---

## ğŸ“ å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ

1. **å‘½åè§„èŒƒ**
   - ç±»å: PascalCase (`AllTrackedMemoryViewModel`)
   - æ–¹æ³•: PascalCase (`LoadSnapshot`)
   - ç§æœ‰å­—æ®µ: _camelCase (`_currentSnapshot`)
   - å±æ€§: PascalCase (`CurrentSnapshot`)

2. **æ³¨é‡Šè§„èŒƒ**
   - æ‰€æœ‰ public ç±»/æ–¹æ³•æ·»åŠ  XML æ³¨é‡Š
   - å¤æ‚é€»è¾‘æ·»åŠ è¡Œå†…æ³¨é‡Š
   - å‚è€ƒ Unity åŸç‰ˆä»£ç ä½ç½®

3. **MVVM è§„èŒƒ**
   - ViewModel ä¸ç›´æ¥å¼•ç”¨ View
   - View é€šè¿‡ DataBinding ç»‘å®š ViewModel
   - Command ä»£æ›¿äº‹ä»¶å¤„ç†

### Git æäº¤è§„èŒƒ

```
<type>(<scope>): <subject>

<type>:
- feat: æ–°åŠŸèƒ½
- fix: ä¿®å¤ bug
- refactor: é‡æ„
- docs: æ–‡æ¡£
- style: æ ·å¼è°ƒæ•´
- test: æµ‹è¯•
- chore: æ„å»º/å·¥å…·

ç¤ºä¾‹:
feat(pathstoroot): Implement recursive reference traversal
fix(treelist): Migrate to DevExpress TreeListControl
refactor(viewmodel): Extract SnapshotDataService
```

---

## ğŸ“š å‚è€ƒèµ„æº

### Unity Memory Profiler ç›¸å…³
- [å®˜æ–¹æ–‡æ¡£](https://docs.unity3d.com/Packages/com.unity.memoryprofiler@1.1/manual/index.html)
- [æºä»£ç ](https://github.com/Unity-Technologies/com.unity.memoryprofiler)

### WPF/MVVM
- [Microsoft WPF æ–‡æ¡£](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/)
- [CommunityToolkit.Mvvm](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/)

### DevExpress WPF
- [TreeListControl æ–‡æ¡£](https://docs.devexpress.com/WPF/DevExpress.Xpf.Grid.TreeListControl)
- [Data Grid ç¤ºä¾‹](https://github.com/DevExpress-Examples/wpf-data-grid-get-started)

---

## âœ… æ€»ç»“

æœ¬å¼€å‘è®¡åˆ’æä¾›äº†å®Œæ•´çš„è·¯çº¿å›¾,ä»ç´§æ€¥ä¿®å¤åˆ°åŠŸèƒ½å®Œå–„,å†åˆ° UI/UX ä¼˜åŒ–å’Œæµ‹è¯•æ–‡æ¡£,é¢„è®¡ **3-4 å‘¨**å®Œæˆæ‰€æœ‰å‰©ä½™å·¥ä½œã€‚

å»ºè®®æŒ‰ç…§ä»¥ä¸‹ä¼˜å…ˆçº§æ‰§è¡Œ:
1. **ç¬¬ä¸€å‘¨**: ä¿®å¤ä¸¥é‡é”™è¯¯ + å®ç° PathsToRoot (å®Œæˆåº¦ â†’ 85%)
2. **ç¬¬äºŒå‘¨**: å®Œå–„è¿‡æ»¤/æœç´¢ + è¡¥å…¨ Unity Objects (å®Œæˆåº¦ â†’ 90%)
3. **ç¬¬ä¸‰å‘¨**: å®ç° Memory Map + UI/UX ä¼˜åŒ– (å®Œæˆåº¦ â†’ 95%)
4. **ç¬¬å››å‘¨**: æµ‹è¯• + æ–‡æ¡£ + æ‰“ç£¨ç»†èŠ‚ (å®Œæˆåº¦ â†’ 100%)

ç¥å¼€å‘é¡ºåˆ©! ğŸš€

